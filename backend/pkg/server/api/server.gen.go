// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ConditionStatus.
const (
	ConditionStatusError        ConditionStatus = "Error"
	ConditionStatusEstablished  ConditionStatus = "Established"
	ConditionStatusNone         ConditionStatus = "None"
	ConditionStatusNotReady     ConditionStatus = "NotReady"
	ConditionStatusPending      ConditionStatus = "Pending"
	ConditionStatusReady        ConditionStatus = "Ready"
	ConditionStatusSomeNotReady ConditionStatus = "SomeNotReady"
)

// Defines values for ForeignClusterRole.
const (
	ForeignClusterRoleConsumer            ForeignClusterRole = "Consumer"
	ForeignClusterRoleConsumerAndProvider ForeignClusterRole = "ConsumerAndProvider"
	ForeignClusterRoleProvider            ForeignClusterRole = "Provider"
	ForeignClusterRoleUnknown             ForeignClusterRole = "Unknown"
)

// Defines values for NamespaceStatus.
const (
	Active      NamespaceStatus = "Active"
	Terminating NamespaceStatus = "Terminating"
)

// Defines values for OffloadingNamespaceMappingStrategy.
const (
	DefaultName     OffloadingNamespaceMappingStrategy = "DefaultName"
	EnforceSameName OffloadingNamespaceMappingStrategy = "EnforceSameName"
	SelectedName    OffloadingNamespaceMappingStrategy = "SelectedName"
)

// Defines values for OffloadingOffloadingPhase.
const (
	OffloadingOffloadingPhaseAllFailed         OffloadingOffloadingPhase = "AllFailed"
	OffloadingOffloadingPhaseInProgress        OffloadingOffloadingPhase = "InProgress"
	OffloadingOffloadingPhaseNoClusterSelected OffloadingOffloadingPhase = "NoClusterSelected"
	OffloadingOffloadingPhaseReady             OffloadingOffloadingPhase = "Ready"
	OffloadingOffloadingPhaseSomeFailed        OffloadingOffloadingPhase = "SomeFailed"
	OffloadingOffloadingPhaseTerminating       OffloadingOffloadingPhase = "Terminating"
)

// Defines values for OffloadingPodOffloadingStrategy.
const (
	OffloadingPodOffloadingStrategyLocal          OffloadingPodOffloadingStrategy = "Local"
	OffloadingPodOffloadingStrategyLocalAndRemote OffloadingPodOffloadingStrategy = "LocalAndRemote"
	OffloadingPodOffloadingStrategyRemote         OffloadingPodOffloadingStrategy = "Remote"
)

// Defines values for PodRestartPolicy.
const (
	Always    PodRestartPolicy = "Always"
	Never     PodRestartPolicy = "Never"
	OnFailure PodRestartPolicy = "OnFailure"
)

// Defines values for PodStatus.
const (
	PodStatusFailed    PodStatus = "Failed"
	PodStatusPending   PodStatus = "Pending"
	PodStatusRunning   PodStatus = "Running"
	PodStatusSucceeded PodStatus = "Succeeded"
	PodStatusUnknown   PodStatus = "Unknown"
)

// Defines values for GetV1ClustersParamsClusterType.
const (
	GetV1ClustersParamsClusterTypeAll    GetV1ClustersParamsClusterType = "All"
	GetV1ClustersParamsClusterTypeLocal  GetV1ClustersParamsClusterType = "Local"
	GetV1ClustersParamsClusterTypeRemote GetV1ClustersParamsClusterType = "Remote"
)

// ConditionStatus defines model for ConditionStatus.
type ConditionStatus string

// ForeignCluster defines model for ForeignCluster.
type ForeignCluster struct {
	ApiServerStatus      *ConditionStatus    `json:"apiServerStatus,omitempty"`
	ApiServerUrl         *string             `json:"apiServerUrl,omitempty"`
	AuthenticationStatus *ConditionStatus    `json:"authenticationStatus,omitempty"`
	Id                   *string             `json:"id,omitempty"`
	NetworkLatency       *string             `json:"networkLatency,omitempty"`
	NetworkStatus        *ConditionStatus    `json:"networkStatus,omitempty"`
	OffloadingStatus     *ConditionStatus    `json:"offloadingStatus,omitempty"`
	ResourcesAcquired    *Resources          `json:"resourcesAcquired,omitempty"`
	ResourcesOffered     *Resources          `json:"resourcesOffered,omitempty"`
	Role                 *ForeignClusterRole `json:"role,omitempty"`
}

// ForeignClusterRole defines model for ForeignCluster.Role.
type ForeignClusterRole string

// Namespace defines model for Namespace.
type Namespace struct {
	CreationTime *string          `json:"creationTime,omitempty"`
	Name         *string          `json:"name,omitempty"`
	Offloading   *Offloading      `json:"offloading,omitempty"`
	Status       *NamespaceStatus `json:"status,omitempty"`
}

// NamespaceStatus defines model for Namespace.Status.
type NamespaceStatus string

// Node defines model for Node.
type Node struct {
	Capacity     *Resources `json:"capacity,omitempty"`
	CapacityUsed *Resources `json:"capacityUsed,omitempty"`
	ClusterID    *string    `json:"clusterID,omitempty"`
	Name         *string    `json:"name,omitempty"`
}

// Offloading defines model for Offloading.
type Offloading struct {
	NamespaceMappingStrategy *OffloadingNamespaceMappingStrategy `json:"namespaceMappingStrategy,omitempty"`
	OffloadingPhase          *OffloadingOffloadingPhase          `json:"offloadingPhase,omitempty"`
	PodOffloadingStrategy    *OffloadingPodOffloadingStrategy    `json:"podOffloadingStrategy,omitempty"`
}

// OffloadingNamespaceMappingStrategy defines model for Offloading.NamespaceMappingStrategy.
type OffloadingNamespaceMappingStrategy string

// OffloadingOffloadingPhase defines model for Offloading.OffloadingPhase.
type OffloadingOffloadingPhase string

// OffloadingPodOffloadingStrategy defines model for Offloading.PodOffloadingStrategy.
type OffloadingPodOffloadingStrategy string

// Pod defines model for Pod.
type Pod struct {
	CreationTime  *string            `json:"creationTime,omitempty"`
	Images        *[]string          `json:"images,omitempty"`
	Labels        *map[string]string `json:"labels,omitempty"`
	Name          *string            `json:"name,omitempty"`
	Namespace     *string            `json:"namespace,omitempty"`
	NodeName      *string            `json:"nodeName,omitempty"`
	RestartPolicy *PodRestartPolicy  `json:"restartPolicy,omitempty"`
	Status        *PodStatus         `json:"status,omitempty"`
}

// PodRestartPolicy defines model for Pod.RestartPolicy.
type PodRestartPolicy string

// PodStatus defines model for Pod.Status.
type PodStatus string

// Resources defines model for Resources.
type Resources struct {
	Cpu              *string `json:"cpu,omitempty"`
	EphemeralStorage *string `json:"ephemeralStorage,omitempty"`
	Memory           *string `json:"memory,omitempty"`
	Pods             *string `json:"pods,omitempty"`
}

// GetV1ClustersParams defines parameters for GetV1Clusters.
type GetV1ClustersParams struct {
	ClusterType *GetV1ClustersParamsClusterType `form:"ClusterType,omitempty" json:"ClusterType,omitempty"`
}

// GetV1ClustersParamsClusterType defines parameters for GetV1Clusters.
type GetV1ClustersParamsClusterType string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Health check
	// (GET /healthz)
	GetHealthz(c *gin.Context)
	// Get list of clusters
	// (GET /v1/clusters)
	GetV1Clusters(c *gin.Context, params GetV1ClustersParams)
	// Get cluster by ID
	// (GET /v1/clusters/{id})
	GetV1ClustersId(c *gin.Context, id string)
	// Get nodes of a cluster by cluster ID
	// (GET /v1/clusters/{id}/nodes)
	GetV1ClustersIdNodes(c *gin.Context, id string)
	// Get list of namespaces
	// (GET /v1/namespaces)
	GetV1Namespaces(c *gin.Context)
	// Get namespace by name
	// (GET /v1/namespaces/{name})
	GetV1NamespacesName(c *gin.Context, name string)
	// Get offloaded pods by namespace name
	// (GET /v1/namespaces/{name}/offloaded)
	GetV1NamespacesNameOffloaded(c *gin.Context, name string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetHealthz operation middleware
func (siw *ServerInterfaceWrapper) GetHealthz(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealthz(c)
}

// GetV1Clusters operation middleware
func (siw *ServerInterfaceWrapper) GetV1Clusters(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetV1ClustersParams

	// ------------- Optional query parameter "ClusterType" -------------

	err = runtime.BindQueryParameter("form", true, false, "ClusterType", c.Request.URL.Query(), &params.ClusterType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter ClusterType: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV1Clusters(c, params)
}

// GetV1ClustersId operation middleware
func (siw *ServerInterfaceWrapper) GetV1ClustersId(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV1ClustersId(c, id)
}

// GetV1ClustersIdNodes operation middleware
func (siw *ServerInterfaceWrapper) GetV1ClustersIdNodes(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV1ClustersIdNodes(c, id)
}

// GetV1Namespaces operation middleware
func (siw *ServerInterfaceWrapper) GetV1Namespaces(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV1Namespaces(c)
}

// GetV1NamespacesName operation middleware
func (siw *ServerInterfaceWrapper) GetV1NamespacesName(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV1NamespacesName(c, name)
}

// GetV1NamespacesNameOffloaded operation middleware
func (siw *ServerInterfaceWrapper) GetV1NamespacesNameOffloaded(c *gin.Context) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", c.Param("name"), &name, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetV1NamespacesNameOffloaded(c, name)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/healthz", wrapper.GetHealthz)
	router.GET(options.BaseURL+"/v1/clusters", wrapper.GetV1Clusters)
	router.GET(options.BaseURL+"/v1/clusters/:id", wrapper.GetV1ClustersId)
	router.GET(options.BaseURL+"/v1/clusters/:id/nodes", wrapper.GetV1ClustersIdNodes)
	router.GET(options.BaseURL+"/v1/namespaces", wrapper.GetV1Namespaces)
	router.GET(options.BaseURL+"/v1/namespaces/:name", wrapper.GetV1NamespacesName)
	router.GET(options.BaseURL+"/v1/namespaces/:name/offloaded", wrapper.GetV1NamespacesNameOffloaded)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9SX308jNxDH/5XI7eNeNuEqtcpbBHcUlSYRgT4U3YOxJ4kPr8fY3sA2yv9e2fs7u0By",
	"aqurhBSvPf4xn/nO2OwIw0SjAuUsmeyIZRtIaGieo+LCCVRLR10aukClCZnckxkqIBFZgOJCrUlEPllH",
	"H6SwG+D+yxg0JCI3QHlGIjJDVzaXmED1+SUiLtNAJsQ64xfaR+QzGhBrdS5T68D4TbVBDcYJCEegWizB",
	"bMHUp/rRwIpMyA9x7Upc+BEfOrGP6hXujPTTO0egqduAcoLRtvcn7iN47+oK3DOax2vqQLHsLZNv3hlX",
	"K4nUh+ablzBgMTUM7JQ9pcIAf2+Nm3JCa/Z8tYKTJ6OEptjOUdk0AS+ohcGt4KFZ9k4Vb/TeqUeFz6pH",
	"WfuqBx++AnN+pxlNwGrKoCszZiBE/1Yk+WFeaKL9ucjZ6Gz8YfTzh9H4djSahL8/SY+QFc1ndgbq6LyH",
	"ZV5b7iNiO2k4ZU5sfSLegkmEos5bHuk68j6vqaZMuOykeJWT7uyJgWZ5jl9d9CdBP78+Z+Ytom2XVBnj",
	"36nWISMMdbDOmhw/qRUaBkuagJcEicgFrGgqXfG1BAnMAQ+ffUWrDuliQ21LvXUNLEpauRiJyJVaGFwb",
	"sLaojJ+pkGFkKmXVfju4EdHI542E77p3jYzKUI4TdN6f0DFVvOg4TjEL5P9GmoiErvO1qrn3BNQWM23w",
	"JYtD8wOVWiiYbMfD8S/DjyQiai3Uy2Q8HP80PPMOCAeJ7dVR0UGNoZn/lvQBZH6V8LzqUbloOdVZojqZ",
	"v340meS7kz5Kr2a9ataa7ijyXHp9gwaso8YtUArWCuxUPtPMa2euvFpS44M7gy2YXqF0C0h9gd+kSuWt",
	"ZcoYAA/SqzR4Wl2ts7wrGJ22dTLuEwXoDSRgqFw6NHR9IK3x6FL0zUogQZMdZ6uR2wPL8Ygc4Z3vEmqF",
	"IVLChanX4gkHDjVKXGcDTu3mAanx3LZgrEDllx+OhqNQKzQoqgWZkI+hKyKauk04TLwBKt3mL99eg/M/",
	"nl3IsCtOJuQS3K+FSZCFRmVzrmejkf/hYJkR2uV7zn8LHtg0SagHQ/LJA7YB9hiG4u04LsqwfWvXP8bn",
	"pZU/r6EJ5FPud0T4rZ5SML7M5fonhfWtZxcVj8q2cmVZh+rC1COuL/1uMlQOlCsSUhYvtfir9W7vGvtV",
	"ZeGtS+ngydmpGR5UG+x0IIV1A1wNKnht0Jfg+k2awOOd4PvjqF/xV7h77dTYBQ+6KF9szqTQpP9P0z0F",
	"ah9EVg0esitGBg/Z4OqiH1zsa6Y9Ft8sGP/PGIZHWi85lY8cYgtIvOZok2DZbJCsbqN3AM5qu/8iE+sH",
	"+UlJ2PDm9TQ8MGpTiHe+vT8WRvEufF9MKjf8TuRU0+3VVGO4I6xyzOspOPUqw7h4DOf/DBxLc15N+i6x",
	"HqVe/0I+SbcVqUF4jnSxtw1K9nkgiijs938HAAD//9ODOYLDEQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
